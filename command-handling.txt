Command handling
Unless your bot project is small, it's not a very good idea to have a single file with a giant if/else if chain for commands. If you want to implement features into your bot and make your development process a lot less painful, you'll want to implement a command handler. Let's get started on that!

#Loading command files
Now that your command files have been created, your bot needs to load these files on startup.

In your index.js file, make these additions to the base template:

const fs = require('node:fs');
const path = require('node:path');
const { Client, Collection, Events, GatewayIntentBits } = require('discord.js');
const { token } = require('./config.json');

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

client.commands = new Collection();
We recommend attaching a .commands property to your client instance so that you can access your commands in other files. The rest of the examples in this guide will follow this convention. For TypeScript users, we recommend extending the base Client class to add this property, casting, or augmenting the module type.

TIP

The fs module is Node's native file system module. fs is used to read the commands directory and identify our command files.
The path module is Node's native path utility module. path helps construct paths to access files and directories. One of the advantages of the path module is that it automatically detects the operating system and uses the appropriate joiners.
The Collection class extends JavaScript's native Map class, and includes more extensive, useful functionality. Collection is used to store and efficiently retrieve commands for execution.
Next, using the modules imported above, dynamically retrieve your command files with a few more additions to the index.js file:

client.commands = new Collection();

const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

for (const file of commandFiles) {
	const filePath = path.join(commandsPath, file);
	const command = require(filePath);
	// Set a new item in the Collection with the key as the command name and the value as the exported module
	if ('data' in command && 'execute' in command) {
		client.commands.set(command.data.name, command);
	} else {
		console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
	}
}
First, path.join() helps to construct a path to the commands directory. The fs.readdirSync() method then reads the path to the directory and returns an array of all the file names it contains, currently ['ping.js', 'server.js', 'user.js']. To ensure only command files get processed, Array.filter() removes any non-JavaScript files from the array.

With the correct files identified, the last step is to loop over the array and dynamically set each command into the client.commands Collection. For each file being loaded, check that it has at least the data and execute properties. This helps to prevent errors resulting from loading empty, unfinished or otherwise incorrect command files while you're still developing.

#Receiving command interactions
Every slash command is an interaction, so to respond to a command, you need to create a listener for the Client#event:interactionCreate event that will execute code when your application receives an interaction. Place the code below in the index.js file you created earlier.

client.on(Events.InteractionCreate, interaction => {
	console.log(interaction);
});
Not every interaction is a slash command (e.g. MessageComponent interactions). Make sure to only handle slash commands in this function by making use of the BaseInteraction#isChatInputCommand method to exit the handler if another type is encountered. This method also provides typeguarding for TypeScript users, narrowing the type from BaseInteraction to ChatInputCommandInteraction.

client.on(Events.InteractionCreate, interaction => {
	if (!interaction.isChatInputCommand()) return;
	console.log(interaction);
});
#Executing commands
When your bot receives a Client#event:interactionCreate event, the interaction object contains all the information you need to dynamically retrieve and execute your commands!

Let's take a look at the ping command again. Note the execute() function that will reply to the interaction with "Pong!".

module.exports = {
	data: new SlashCommandBuilder()
		.setName('ping')
		.setDescription('Replies with Pong!'),
	async execute(interaction) {
		await interaction.reply('Pong!');
	},
};
First, you need to get the matching command from the client.commands Collection based on the interaction.commandName. Your Client instance is always available via interaction.client. If no matching command is found, log an error to the console and ignore the event.

With the right command identified, all that's left to do is call the command's .execute() method and pass in the interaction variable as its argument. In case something goes wrong, catch and log any error to the console.

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	const command = interaction.client.commands.get(interaction.commandName);

	if (!command) {
		console.error(`No command matching ${interaction.commandName} was found.`);
		return;
	}

	try {
		await command.execute(interaction);
	} catch (error) {
		console.error(error);
		if (interaction.replied || interaction.deferred) {
			await interaction.followUp({ content: 'There was an error while executing this command!', ephemeral: true });
		} else {
			await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });
		}
	}
});
#Next steps
Your command files are now loaded into your bot, and the event listener is prepared and ready to respond. In the next section, we cover the final step - a command deployment script you'll need to register your commands so they appear in the Discord client.

#Resulting code
If you want to compare your code to the code we've constructed so far, you can review it over on the GitHub repository here .

It also includes some bonus commands!